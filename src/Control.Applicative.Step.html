<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE EmptyDataDeriving #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module      : Control.Applicative.Step</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright   : (c) Justin Le 2019</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License     : BSD3</span><span>
</span><span id="line-7"></span><span class="hs-comment">--</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Maintainer  : justin@jle.im</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Stability   : experimental</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Portability : non-portable</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- This module provides functor combinators that are the fixed points of</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- applications of ':+:' and 'Data.Functor.These.These1'.  They are useful</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- for their 'Data.HFunctor.Interpret.Interpret' instances, along with</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- their relationship to the 'Data.HBifunctor.Tensor.Monoidal' instances of</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- ':+:' and 'Data.Functor.These.These1'.</span><span>
</span><span id="line-17"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Applicative.Step</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-18"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Fixed Points</span></span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier">Step</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier">Steps</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier">Flagged</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Steppers</span></span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier">stepUp</span></a></span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier">stepDown</span></a></span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier">stepping</span></a></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier">stepsUp</span></a></span><span>
</span><span id="line-27"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier">stepsDown</span></a></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier">steppings</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Void</span></span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier">absurd1</span></a></span><span>
</span><span id="line-31"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier">Void2</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier">absurd2</span></a></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier">Void3</span></a></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier">absurd3</span></a></span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Natural</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Control.Natural.IsoF.html"><span class="hs-identifier">Control.Natural.IsoF</span></a></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Deriving</span></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Alt</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Bind</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Contravariant</span></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Functor.Contravariant.Conclude.html"><span class="hs-identifier">Data.Functor.Contravariant.Conclude</span></a></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Functor.Contravariant.Decide.html"><span class="hs-identifier">Data.Functor.Contravariant.Decide</span></a></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Functor.Contravariant.Divise.html"><span class="hs-identifier">Data.Functor.Contravariant.Divise</span></a></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Contravariant.Divisible</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Invariant</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.These</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NEMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Pointed</span></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup</span></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Foldable</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Traversable</span></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.These</span></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Natural</span></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>                    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NEM</span></span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-comment">-- | An @f a@, along with a 'Natural' index.</span><span>
</span><span id="line-62"></span><span class="hs-comment">--</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-64"></span><span class="hs-comment">-- 'Step' f a ~ ('Natural', f a)</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- Step f   ~ ((,) Natural) ':.:' f       -- functor composition</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-67"></span><span class="hs-comment">--</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- It is the fixed point of infinite applications of ':+:' (functor sums).</span><span>
</span><span id="line-69"></span><span class="hs-comment">--</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- Intuitively, in an infinite @f :+: f :+: f :+: f ...@, you have</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- exactly one @f@ /somewhere/.  A @'Step' f a@ has that @f@, with</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- a 'Natural' giving you &quot;where&quot; the @f@ is in the long chain.</span><span>
</span><span id="line-73"></span><span class="hs-comment">--</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal'</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- instance of ':+:'.</span><span>
</span><span id="line-76"></span><span class="hs-comment">--</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-79"></span><span class="hs-comment">--</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- Note that this type and its instances equivalent to</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- @'Control.Comonad.Trans.Env.EnvT' ('Data.Semigroup.Sum' 'Natural')@.</span><span>
</span><span id="line-82"></span><span id="local-6989586621679616082"><span id="local-6989586621679616083"></span></span><span class="hs-keyword">data</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span id="local-6989586621679616896"><span class="annot"><a href="#local-6989586621679616896"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679616895"><span class="annot"><a href="#local-6989586621679616895"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="stepPos"><span class="annot"><span class="annottext">Step f a -&gt; Natural
</span><a href="Control.Applicative.Step.html#stepPos"><span class="hs-identifier hs-var hs-var">stepPos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span class="hs-special">,</span><span> </span><span id="stepVal"><span class="annot"><span class="annottext">Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679616896"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616895"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679616073"><span id="local-6989586621679616075"><span id="local-6989586621679616077"><span class="annot"><span class="annottext">Int -&gt; Step f a -&gt; ShowS
[Step f a] -&gt; ShowS
Step f a -&gt; String
(Int -&gt; Step f a -&gt; ShowS)
-&gt; (Step f a -&gt; String) -&gt; ([Step f a] -&gt; ShowS) -&gt; Show (Step f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showList :: [Step f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
show :: Step f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showsPrec :: Int -&gt; Step f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679616064"><span id="local-6989586621679616066"><span id="local-6989586621679616068"><span id="local-6989586621679616070"><span class="annot"><span class="annottext">ReadPrec [Step f a]
ReadPrec (Step f a)
Int -&gt; ReadS (Step f a)
ReadS [Step f a]
(Int -&gt; ReadS (Step f a))
-&gt; ReadS [Step f a]
-&gt; ReadPrec (Step f a)
-&gt; ReadPrec [Step f a]
-&gt; Read (Step f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readListPrec :: ReadPrec [Step f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
readPrec :: ReadPrec (Step f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
readList :: ReadS [Step f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readsPrec :: Int -&gt; ReadS (Step f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679616059"><span id="local-6989586621679616061"><span class="annot"><span class="annottext">Step f a -&gt; Step f a -&gt; Bool
(Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool) -&gt; Eq (Step f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
/= :: Step f a -&gt; Step f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
== :: Step f a -&gt; Step f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679616043"><span id="local-6989586621679616045"><span id="local-6989586621679616047"><span id="local-6989586621679616049"><span id="local-6989586621679616051"><span id="local-6989586621679616053"><span id="local-6989586621679616055"><span class="annot"><span class="annottext">Eq (Step f a)
Eq (Step f a) =&gt;
(Step f a -&gt; Step f a -&gt; Ordering)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; Ord (Step f a)
Step f a -&gt; Step f a -&gt; Bool
Step f a -&gt; Step f a -&gt; Ordering
Step f a -&gt; Step f a -&gt; Step f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
min :: Step f a -&gt; Step f a -&gt; Step f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
max :: Step f a -&gt; Step f a -&gt; Step f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
&gt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&gt; :: Step f a -&gt; Step f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt; :: Step f a -&gt; Step f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
compare :: Step f a -&gt; Step f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679616038"><span id="local-6989586621679616040"><span class="annot"><span class="annottext">a -&gt; Step f b -&gt; Step f a
(a -&gt; b) -&gt; Step f a -&gt; Step f b
(forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b)
-&gt; (forall a b. a -&gt; Step f b -&gt; Step f a) -&gt; Functor (Step f)
forall a b. a -&gt; Step f b -&gt; Step f a
forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Step f b -&gt; Step f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
fmap :: (a -&gt; b) -&gt; Step f a -&gt; Step f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679616003"><span id="local-6989586621679616005"><span id="local-6989586621679616007"><span id="local-6989586621679616009"><span id="local-6989586621679616011"><span id="local-6989586621679616013"><span id="local-6989586621679616015"><span id="local-6989586621679616017"><span id="local-6989586621679616019"><span id="local-6989586621679616021"><span id="local-6989586621679616023"><span id="local-6989586621679616025"><span id="local-6989586621679616027"><span id="local-6989586621679616029"><span id="local-6989586621679616031"><span id="local-6989586621679616033"><span id="local-6989586621679616035"><span class="annot"><span class="annottext">Step f a -&gt; Bool
(a -&gt; m) -&gt; Step f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
(forall m. Monoid m =&gt; Step f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. Step f a -&gt; [a])
-&gt; (forall a. Step f a -&gt; Bool)
-&gt; (forall a. Step f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; Foldable (Step f)
forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool
forall a. Num a =&gt; Step f a -&gt; a
forall a. Ord a =&gt; Step f a -&gt; a
forall m. Monoid m =&gt; Step f m -&gt; m
forall a. Step f a -&gt; Bool
forall a. Step f a -&gt; Int
forall a. Step f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Step f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
sum :: Step f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
minimum :: Step f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
maximum :: Step f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
elem :: a -&gt; Step f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
length :: Step f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
null :: Step f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
toList :: Step f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
fold :: Step f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615992"><span id="local-6989586621679615994"><span id="local-6989586621679615996"><span id="local-6989586621679615998"><span class="annot"><span class="annottext">Functor (Step f)
Foldable (Step f)
(Functor (Step f), Foldable (Step f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Step f (f a) -&gt; f (Step f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Step f (m a) -&gt; m (Step f a))
-&gt; Traversable (Step f)
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Step f (f a) -&gt; f (Step f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
sequence :: Step f (m a) -&gt; m (Step f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
mapM :: (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
sequenceA :: Step f (f a) -&gt; f (Step f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
traverse :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Step f a -&gt; Rep (Step f a) x)
-&gt; (forall x. Rep (Step f a) x -&gt; Step f a) -&gt; Generic (Step f a)
forall x. Rep (Step f a) x -&gt; Step f a
forall x. Step f a -&gt; Rep (Step f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cStep"><span id="%24tStep"><span id="local-6989586621679615959"><span id="local-6989586621679615961"><span id="local-6989586621679615963"><span id="local-6989586621679615965"><span id="local-6989586621679615967"><span id="local-6989586621679615969"><span id="local-6989586621679615971"><span id="local-6989586621679615973"><span id="local-6989586621679615975"><span id="local-6989586621679615977"><span id="local-6989586621679615979"><span id="local-6989586621679615981"><span id="local-6989586621679615983"><span id="local-6989586621679615985"><span class="annot"><span class="annottext">Typeable (Step f a)
DataType
Constr
Typeable (Step f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a))
-&gt; (Step f a -&gt; Constr)
-&gt; (Step f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Step f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; Data (Step f a)
Step f a -&gt; DataType
Step f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cStep :: Constr
$tStep :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
dataTypeOf :: Step f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
toConstr :: Step f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span id="local-6989586621679615952"><span id="local-6989586621679615954"><span id="local-6989586621679616896"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span><span>
</span><span id="line-86"></span><span id="local-6989586621679615942"><span id="local-6989586621679615944"><span id="local-6989586621679615946"><span id="local-6989586621679615948"><span id="local-6989586621679616896"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span></span></span><span>
</span><span id="line-87"></span><span id="local-6989586621679615937"><span id="local-6989586621679616896"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-88"></span><span id="local-6989586621679615932"><span id="local-6989586621679616896"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-91"></span><span id="local-6989586621679615929"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615921"><span id="local-6989586621679615923"><span id="local-6989586621679615925"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="annot"><a href="#local-6989586621679615929"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615929"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-92"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615919"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615919"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615918"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679615918"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679615917"><span class="annot"><span class="annottext">&lt;.&gt; :: Step f (a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615915"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615915"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615914"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615914"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615919"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615915"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679615918"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Apply f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;.&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615914"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span id="local-6989586621679615912"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615903"><span id="local-6989586621679615905"><span id="local-6989586621679615907"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679615912"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615912"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-95"></span><span>    </span><span id="local-6989586621679615901"><span class="annot"><span class="annottext">pure :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-96"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615899"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615899"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615898"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679615898"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679615897"><span class="annot"><span class="annottext">&lt;*&gt; :: Step f (a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615896"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615896"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615895"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615895"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615899"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615896"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679615898"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615895"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-99"></span><span id="local-6989586621679615894"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615891"><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="annot"><a href="#local-6989586621679615894"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615894"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-100"></span><span>    </span><span id="local-6989586621679615889"><span class="annot"><span class="annottext">contramap :: (a -&gt; b) -&gt; Step f b -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">contramap</span></span></span><span> </span><span id="local-6989586621679615887"><span class="annot"><span class="annottext">f :: a -&gt; b
</span><a href="#local-6989586621679615887"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615886"><span class="annot"><span class="annottext">x :: Natural
</span><a href="#local-6989586621679615886"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615885"><span class="annot"><span class="annottext">y :: f b
</span><a href="#local-6989586621679615885"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615886"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; f b -&gt; f a
forall (f :: * -&gt; *) a b. Contravariant f =&gt; (a -&gt; b) -&gt; f b -&gt; f a
</span><span class="hs-identifier hs-var">contramap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679615887"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679615885"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-103"></span><span id="local-6989586621679615884"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Divisible</span></span><span> </span><span class="annot"><a href="#local-6989586621679615884"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Divisible</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615884"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-104"></span><span>    </span><span id="local-6989586621679615879"><span class="annot"><span class="annottext">divide :: (a -&gt; (b, c)) -&gt; Step f b -&gt; Step f c -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">divide</span></span></span><span> </span><span id="local-6989586621679615877"><span class="annot"><span class="annottext">f :: a -&gt; (b, c)
</span><a href="#local-6989586621679615877"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615876"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615876"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615875"><span class="annot"><span class="annottext">x :: f b
</span><a href="#local-6989586621679615875"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615874"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615874"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615873"><span class="annot"><span class="annottext">y :: f c
</span><a href="#local-6989586621679615873"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615876"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615874"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; (b, c)) -&gt; f b -&gt; f c -&gt; f a
forall (f :: * -&gt; *) a b c.
Divisible f =&gt;
(a -&gt; (b, c)) -&gt; f b -&gt; f c -&gt; f a
</span><span class="hs-identifier hs-var">divide</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; (b, c)
</span><a href="#local-6989586621679615877"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679615875"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">f c
</span><a href="#local-6989586621679615873"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>    </span><span id="local-6989586621679615872"><span class="annot"><span class="annottext">conquer :: Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">conquer</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f a
forall (f :: * -&gt; *) a. Divisible f =&gt; f a
</span><span class="hs-identifier hs-var">conquer</span></span></span><span>
</span><span id="line-106"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-107"></span><span id="local-6989586621679615870"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Divise.html#Divise"><span class="hs-identifier hs-type">Divise</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615870"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Divise.html#Divise"><span class="hs-identifier hs-type">Divise</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615870"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-108"></span><span>    </span><span id="local-6989586621679615866"><span class="annot"><span class="annottext">divise :: (a -&gt; (b, c)) -&gt; Step f b -&gt; Step f c -&gt; Step f a
</span><a href="Data.Functor.Contravariant.Divise.html#divise"><span class="hs-identifier hs-var hs-var hs-var hs-var">divise</span></a></span></span><span> </span><span id="local-6989586621679615864"><span class="annot"><span class="annottext">f :: a -&gt; (b, c)
</span><a href="#local-6989586621679615864"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615863"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615863"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615862"><span class="annot"><span class="annottext">x :: f b
</span><a href="#local-6989586621679615862"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615861"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615861"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615860"><span class="annot"><span class="annottext">y :: f c
</span><a href="#local-6989586621679615860"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615863"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615861"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; (b, c)) -&gt; f b -&gt; f c -&gt; f a
forall (f :: * -&gt; *) a b c.
Divise f =&gt;
(a -&gt; (b, c)) -&gt; f b -&gt; f c -&gt; f a
</span><a href="Data.Functor.Contravariant.Divise.html#divise"><span class="hs-identifier hs-var">divise</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; (b, c)
</span><a href="#local-6989586621679615864"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679615862"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">f c
</span><a href="#local-6989586621679615860"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-111"></span><span id="local-6989586621679615859"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Decide.html#Decide"><span class="hs-identifier hs-type">Decide</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615859"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Decide.html#Decide"><span class="hs-identifier hs-type">Decide</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615859"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-112"></span><span>    </span><span id="local-6989586621679615855"><span class="annot"><span class="annottext">decide :: (a -&gt; Either b c) -&gt; Step f b -&gt; Step f c -&gt; Step f a
</span><a href="Data.Functor.Contravariant.Decide.html#decide"><span class="hs-identifier hs-var hs-var hs-var hs-var">decide</span></a></span></span><span> </span><span id="local-6989586621679615853"><span class="annot"><span class="annottext">f :: a -&gt; Either b c
</span><a href="#local-6989586621679615853"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615852"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615852"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615851"><span class="annot"><span class="annottext">x :: f b
</span><a href="#local-6989586621679615851"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615850"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615850"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615849"><span class="annot"><span class="annottext">y :: f c
</span><a href="#local-6989586621679615849"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615852"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615850"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Either b c) -&gt; f b -&gt; f c -&gt; f a
forall (f :: * -&gt; *) a b c.
Decide f =&gt;
(a -&gt; Either b c) -&gt; f b -&gt; f c -&gt; f a
</span><a href="Data.Functor.Contravariant.Decide.html#decide"><span class="hs-identifier hs-var">decide</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Either b c
</span><a href="#local-6989586621679615853"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679615851"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">f c
</span><a href="#local-6989586621679615849"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-113"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-114"></span><span id="local-6989586621679615848"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Conclude.html#Conclude"><span class="hs-identifier hs-type">Conclude</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615848"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Contravariant.Conclude.html#Conclude"><span class="hs-identifier hs-type">Conclude</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615848"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>    </span><span id="local-6989586621679615844"><span class="annot"><span class="annottext">conclude :: (a -&gt; Void) -&gt; Step f a
</span><a href="Data.Functor.Contravariant.Conclude.html#conclude"><span class="hs-identifier hs-var hs-var hs-var hs-var">conclude</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a)
-&gt; ((a -&gt; Void) -&gt; f a) -&gt; (a -&gt; Void) -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Void) -&gt; f a
forall (f :: * -&gt; *) a. Conclude f =&gt; (a -&gt; Void) -&gt; f a
</span><a href="Data.Functor.Contravariant.Conclude.html#conclude"><span class="hs-identifier hs-var">conclude</span></a></span></span><span>
</span><span id="line-116"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-117"></span><span id="local-6989586621679615842"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Decidable</span></span><span> </span><span class="annot"><a href="#local-6989586621679615842"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Decidable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615842"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-118"></span><span>    </span><span id="local-6989586621679615837"><span class="annot"><span class="annottext">choose :: (a -&gt; Either b c) -&gt; Step f b -&gt; Step f c -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">choose</span></span></span><span> </span><span id="local-6989586621679615835"><span class="annot"><span class="annottext">f :: a -&gt; Either b c
</span><a href="#local-6989586621679615835"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615834"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615834"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615833"><span class="annot"><span class="annottext">x :: f b
</span><a href="#local-6989586621679615833"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615832"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615832"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615831"><span class="annot"><span class="annottext">y :: f c
</span><a href="#local-6989586621679615831"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615834"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615832"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Either b c) -&gt; f b -&gt; f c -&gt; f a
forall (f :: * -&gt; *) a b c.
Decidable f =&gt;
(a -&gt; Either b c) -&gt; f b -&gt; f c -&gt; f a
</span><span class="hs-identifier hs-var">choose</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Either b c
</span><a href="#local-6989586621679615835"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679615833"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">f c
</span><a href="#local-6989586621679615831"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span>    </span><span id="local-6989586621679615830"><span class="annot"><span class="annottext">lose :: (a -&gt; Void) -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">lose</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a)
-&gt; ((a -&gt; Void) -&gt; f a) -&gt; (a -&gt; Void) -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Void) -&gt; f a
forall (f :: * -&gt; *) a. Decidable f =&gt; (a -&gt; Void) -&gt; f a
</span><span class="hs-identifier hs-var">lose</span></span></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-122"></span><span id="local-6989586621679615828"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="annot"><a href="#local-6989586621679615828"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615828"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-123"></span><span>    </span><span id="local-6989586621679615825"><span class="annot"><span class="annottext">invmap :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; Step f a -&gt; Step f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">invmap</span></span></span><span> </span><span id="local-6989586621679615823"><span class="annot"><span class="annottext">f :: a -&gt; b
</span><a href="#local-6989586621679615823"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679615822"><span class="annot"><span class="annottext">g :: b -&gt; a
</span><a href="#local-6989586621679615822"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615821"><span class="annot"><span class="annottext">x :: Natural
</span><a href="#local-6989586621679615821"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615820"><span class="annot"><span class="annottext">y :: f a
</span><a href="#local-6989586621679615820"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615821"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; (b -&gt; a) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b.
Invariant f =&gt;
(a -&gt; b) -&gt; (b -&gt; a) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">invmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679615823"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; a
</span><a href="#local-6989586621679615822"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615820"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span id="local-6989586621679615819"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679615819"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615819"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-126"></span><span>    </span><span id="local-6989586621679615816"><span class="annot"><span class="annottext">point :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span id="local-6989586621679615814"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615814"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615814"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-129"></span><span>    </span><span id="local-6989586621679615808"><span class="annot"><span class="annottext">fold1 :: Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Step f m -&gt; f m) -&gt; Step f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-130"></span><span>    </span><span id="local-6989586621679615806"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Step f a -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></span></span><span> </span><span id="local-6989586621679615804"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679615804"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679615804"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-131"></span><span>    </span><span id="local-6989586621679615803"><span class="annot"><span class="annottext">toNonEmpty :: Step f a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span id="local-6989586621679615801"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615801"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615801"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-134"></span><span>    </span><span id="local-6989586621679615795"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></span></span><span> </span><span id="local-6989586621679615793"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679615793"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615792"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615792"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615791"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615791"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615792"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679615793"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615791"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-135"></span><span>    </span><span id="local-6989586621679615789"><span class="annot"><span class="annottext">sequence1 :: Step f (f b) -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615787"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615787"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615786"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679615786"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615787"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679615786"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Step'.  This is basically</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- a witness that 'stepDown' and 'stepUp' form an isomorphism.</span><span>
</span><span id="line-139"></span><span id="local-6989586621679615785"><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-type">stepping</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615785"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615785"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615785"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-140"></span><span id="stepping"><span class="annot"><span class="annottext">stepping :: p ((:+:) f (Step f) a) ((:+:) f (Step f) a)
-&gt; p (Step f a) (Step f a)
</span><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-var hs-var">stepping</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Step f ~&gt; (f :+: Step f))
-&gt; ((f :+: Step f) ~&gt; Step f) -&gt; Step f &lt;~&gt; (f :+: Step f)
forall k (f :: k -&gt; *) (g :: k -&gt; *).
(f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Step f ~&gt; (f :+: Step f)
forall k (f :: k -&gt; *). Step f ~&gt; (f :+: Step f)
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var">stepDown</span></a></span><span> </span><span class="annot"><span class="annottext">(f :+: Step f) ~&gt; Step f
forall k (f :: k -&gt; *). (f :+: Step f) ~&gt; Step f
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var">stepUp</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-comment">-- | Pop off the first item in a 'Step'.  Because a @'Step' f@ is @f :+:</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-144"></span><span class="hs-comment">--</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-146"></span><span class="hs-comment">--</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-150"></span><span class="hs-comment">--</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-152"></span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-156"></span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- 'stepDown' ('Step' 2 &quot;hello&quot;)</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- -- 'R1' (Step 1 &quot;hello&quot;)</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- stepDown (Step 0 &quot;hello&quot;)</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- -- 'L1' &quot;hello&quot;</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-163"></span><span class="hs-comment">--</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- Forms an isomorphism with 'stepUp' (see 'stepping').</span><span>
</span><span id="line-165"></span><span id="local-6989586621679616761"><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-type">stepDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616761"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679616761"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616761"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-166"></span><span id="stepDown"><span class="annot"><span class="annottext">stepDown :: Step f x -&gt; (:+:) f (Step f) x
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var hs-var">stepDown</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615783"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615783"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615782"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679615782"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615783"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-167"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). f p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">L1</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615782"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-168"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679615779"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679615779"><span class="hs-identifier hs-var">m</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Step f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). g p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615779"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615782"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span>
</span><span id="line-170"></span><span class="hs-comment">-- | Unshift an item into a 'Step'.  Because a @'Step' f@ is @f :+: f :+:</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this basically conses an additional</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-173"></span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-175"></span><span class="hs-comment">--</span><span>
</span><span id="line-176"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-179"></span><span class="hs-comment">--</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-181"></span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-185"></span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- 'stepUp' ('L1' &quot;hello&quot;)</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- -- 'Step' 0 &quot;hello&quot;</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- stepUp ('R1' (Step 1 &quot;hello&quot;))</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- -- Step 2 &quot;hello&quot;</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-192"></span><span class="hs-comment">--</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-194"></span><span id="local-6989586621679616759"><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-type">stepUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679616759"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616759"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616759"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-195"></span><span id="stepUp"><span class="annot"><span class="annottext">stepUp :: (:+:) f (Step f) x -&gt; Step f x
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var hs-var">stepUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-196"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">L1</span></span><span> </span><span id="local-6989586621679615777"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679615777"><span class="hs-identifier hs-var">x</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>       </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615777"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-197"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679615776"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679615776"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615775"><span class="annot"><span class="annottext">y :: f x
</span><a href="#local-6989586621679615775"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615776"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615775"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="hs-comment">-- | We have a natural transformation between 'V1' and any other</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- functor @f@ with no constraints.</span><span>
</span><span id="line-201"></span><span id="local-6989586621679615773"><span id="local-6989586621679615774"><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-type">absurd1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">V1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615774"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679615773"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615774"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-202"></span><span id="absurd1"><span class="annot"><span class="annottext">absurd1 :: V1 a -&gt; f a
</span><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-var hs-var">absurd1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span class="hs-comment">-- | A non-empty map of 'Natural' to @f a@.  Basically, contains multiple</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- @f a@s, each at a given 'Natural' index.</span><span>
</span><span id="line-206"></span><span class="hs-comment">--</span><span>
</span><span id="line-207"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- Steps f a ~ 'M.Map' 'Natural' (f a)</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- Steps f   ~ 'M.Map' 'Natural' ':.:' f       -- functor composition</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-211"></span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- It is the fixed point of applications of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- You can think of this as an infinite sparse array of @f a@s.</span><span>
</span><span id="line-215"></span><span class="hs-comment">--</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- Intuitively, in an infinite @f \`TheseT\` f \`TheseT\` f \`TheseT\` f ...@,</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- each of those infinite positions may have an @f@ in them.  However,</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- because of the at-least-one nature of 'Data.Functor.These.TheseT', we know we have at least</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- one f at one position /somewhere/.</span><span>
</span><span id="line-220"></span><span class="hs-comment">--</span><span>
</span><span id="line-221"></span><span class="hs-comment">-- A @'Steps' f a@ has potentially many @f@s, each stored at a different</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- 'Natural' position, with the guaruntee that at least one @f@ exists.</span><span>
</span><span id="line-223"></span><span class="hs-comment">--</span><span>
</span><span id="line-224"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal' instance</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-226"></span><span class="hs-comment">--</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- 'Data.HFunctor.interpret'ing it requires at least an 'Alt'</span><span>
</span><span id="line-228"></span><span class="hs-comment">-- instance in the target context, since we have to handle potentially more</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- than one @f@.</span><span>
</span><span id="line-230"></span><span class="hs-comment">--</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- This type is essentailly the same as @'Control.Applicative.ListF.NEMapF'</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- ('Sum' 'Natural')@ (except with a different 'Semigroup' instance).</span><span>
</span><span id="line-233"></span><span id="local-6989586621679615771"><span id="local-6989586621679615772"></span></span><span class="hs-keyword">newtype</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span id="local-6989586621679616648"><span class="annot"><a href="#local-6989586621679616648"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679616647"><span class="annot"><a href="#local-6989586621679616647"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="getSteps"><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679616648"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616647"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679615763"><span id="local-6989586621679615765"><span id="local-6989586621679615767"><span class="annot"><span class="annottext">Int -&gt; Steps f a -&gt; ShowS
[Steps f a] -&gt; ShowS
Steps f a -&gt; String
(Int -&gt; Steps f a -&gt; ShowS)
-&gt; (Steps f a -&gt; String)
-&gt; ([Steps f a] -&gt; ShowS)
-&gt; Show (Steps f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showList :: [Steps f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
show :: Steps f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showsPrec :: Int -&gt; Steps f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615755"><span id="local-6989586621679615757"><span id="local-6989586621679615759"><span id="local-6989586621679615761"><span class="annot"><span class="annottext">ReadPrec [Steps f a]
ReadPrec (Steps f a)
Int -&gt; ReadS (Steps f a)
ReadS [Steps f a]
(Int -&gt; ReadS (Steps f a))
-&gt; ReadS [Steps f a]
-&gt; ReadPrec (Steps f a)
-&gt; ReadPrec [Steps f a]
-&gt; Read (Steps f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readListPrec :: ReadPrec [Steps f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
readPrec :: ReadPrec (Steps f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
readList :: ReadS [Steps f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readsPrec :: Int -&gt; ReadS (Steps f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615751"><span id="local-6989586621679615753"><span class="annot"><span class="annottext">Steps f a -&gt; Steps f a -&gt; Bool
(Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool) -&gt; Eq (Steps f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
/= :: Steps f a -&gt; Steps f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
== :: Steps f a -&gt; Steps f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615736"><span id="local-6989586621679615738"><span id="local-6989586621679615740"><span id="local-6989586621679615742"><span id="local-6989586621679615744"><span id="local-6989586621679615746"><span id="local-6989586621679615748"><span class="annot"><span class="annottext">Eq (Steps f a)
Eq (Steps f a) =&gt;
(Steps f a -&gt; Steps f a -&gt; Ordering)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; Ord (Steps f a)
Steps f a -&gt; Steps f a -&gt; Bool
Steps f a -&gt; Steps f a -&gt; Ordering
Steps f a -&gt; Steps f a -&gt; Steps f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
min :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
max :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
&gt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&gt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
compare :: Steps f a -&gt; Steps f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615732"><span id="local-6989586621679615734"><span class="annot"><span class="annottext">a -&gt; Steps f b -&gt; Steps f a
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
(forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b)
-&gt; (forall a b. a -&gt; Steps f b -&gt; Steps f a) -&gt; Functor (Steps f)
forall a b. a -&gt; Steps f b -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Steps f b -&gt; Steps f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
fmap :: (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615698"><span id="local-6989586621679615700"><span id="local-6989586621679615702"><span id="local-6989586621679615704"><span id="local-6989586621679615706"><span id="local-6989586621679615708"><span id="local-6989586621679615710"><span id="local-6989586621679615712"><span id="local-6989586621679615714"><span id="local-6989586621679615716"><span id="local-6989586621679615718"><span id="local-6989586621679615720"><span id="local-6989586621679615722"><span id="local-6989586621679615724"><span id="local-6989586621679615726"><span id="local-6989586621679615728"><span id="local-6989586621679615730"><span class="annot"><span class="annottext">Steps f a -&gt; Bool
(a -&gt; m) -&gt; Steps f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
(forall m. Monoid m =&gt; Steps f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. Steps f a -&gt; [a])
-&gt; (forall a. Steps f a -&gt; Bool)
-&gt; (forall a. Steps f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; Foldable (Steps f)
forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool
forall a. Num a =&gt; Steps f a -&gt; a
forall a. Ord a =&gt; Steps f a -&gt; a
forall m. Monoid m =&gt; Steps f m -&gt; m
forall a. Steps f a -&gt; Bool
forall a. Steps f a -&gt; Int
forall a. Steps f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Steps f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
sum :: Steps f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
minimum :: Steps f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
maximum :: Steps f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
elem :: a -&gt; Steps f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
length :: Steps f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
null :: Steps f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
toList :: Steps f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
fold :: Steps f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615688"><span id="local-6989586621679615690"><span id="local-6989586621679615692"><span id="local-6989586621679615694"><span class="annot"><span class="annottext">Functor (Steps f)
Foldable (Steps f)
(Functor (Steps f), Foldable (Steps f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Steps f (f a) -&gt; f (Steps f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Steps f (m a) -&gt; m (Steps f a))
-&gt; Traversable (Steps f)
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
sequence :: Steps f (m a) -&gt; m (Steps f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
mapM :: (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
sequenceA :: Steps f (f a) -&gt; f (Steps f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
traverse :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Steps f a -&gt; Rep (Steps f a) x)
-&gt; (forall x. Rep (Steps f a) x -&gt; Steps f a)
-&gt; Generic (Steps f a)
forall x. Rep (Steps f a) x -&gt; Steps f a
forall x. Steps f a -&gt; Rep (Steps f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cSteps"><span id="%24tSteps"><span id="local-6989586621679615657"><span id="local-6989586621679615659"><span id="local-6989586621679615661"><span id="local-6989586621679615663"><span id="local-6989586621679615665"><span id="local-6989586621679615667"><span id="local-6989586621679615669"><span id="local-6989586621679615671"><span id="local-6989586621679615673"><span id="local-6989586621679615675"><span id="local-6989586621679615677"><span id="local-6989586621679615679"><span id="local-6989586621679615681"><span id="local-6989586621679615683"><span class="annot"><span class="annottext">Typeable (Steps f a)
DataType
Constr
Typeable (Steps f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a))
-&gt; (Steps f a -&gt; Constr)
-&gt; (Steps f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Steps f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; Data (Steps f a)
Steps f a -&gt; DataType
Steps f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cSteps :: Constr
$tSteps :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
dataTypeOf :: Steps f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
toConstr :: Steps f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-235"></span><span>
</span><span id="line-236"></span><span id="local-6989586621679615651"><span id="local-6989586621679615653"><span id="local-6989586621679616648"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span><span>
</span><span id="line-237"></span><span id="local-6989586621679615643"><span id="local-6989586621679615645"><span id="local-6989586621679615647"><span id="local-6989586621679615649"><span id="local-6989586621679616648"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span></span></span><span>
</span><span id="line-238"></span><span id="local-6989586621679615641"><span id="local-6989586621679616648"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-239"></span><span id="local-6989586621679615638"><span id="local-6989586621679616648"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span id="local-6989586621679615637"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615637"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615637"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-242"></span><span>    </span><span id="local-6989586621679615632"><span class="annot"><span class="annottext">fold1 :: Steps f m -&gt; m
</span><a href="#local-6989586621679615632"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; NEMap Natural (f m) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f m) -&gt; m)
-&gt; (Steps f m -&gt; NEMap Natural (f m)) -&gt; Steps f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f m -&gt; NEMap Natural (f m)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-243"></span><span>    </span><span id="local-6989586621679615631"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Steps f a -&gt; m
</span><a href="#local-6989586621679615631"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679615630"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679615630"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m)
-&gt; ((a -&gt; m) -&gt; f a -&gt; m) -&gt; (a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679615630"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; m)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-244"></span><span>    </span><span id="local-6989586621679615629"><span class="annot"><span class="annottext">toNonEmpty :: Steps f a -&gt; NonEmpty a
</span><a href="#local-6989586621679615629"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; NEMap Natural (f a) -&gt; NonEmpty a
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; NonEmpty a)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span id="local-6989586621679615628"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615628"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615628"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-247"></span><span>    </span><span id="local-6989586621679615623"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
</span><a href="#local-6989586621679615623"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679615622"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679615622"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f a -&gt; f (NEMap Natural (f b)))
-&gt; Steps f a
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; f (f b)) -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; f (f b))
 -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; ((a -&gt; f b) -&gt; f a -&gt; f (f b))
-&gt; (a -&gt; f b)
-&gt; NEMap Natural (f a)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679615622"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f a -&gt; NEMap Natural (f a))
-&gt; Steps f a
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-248"></span><span>    </span><span id="local-6989586621679615621"><span class="annot"><span class="annottext">sequence1 :: Steps f (f b) -&gt; f (Steps f b)
</span><a href="#local-6989586621679615621"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f (f b) -&gt; f (NEMap Natural (f b)))
-&gt; Steps f (f b)
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f (f b) -&gt; f (f b))
-&gt; NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f (f b) -&gt; NEMap Natural (f (f b)))
-&gt; Steps f (f b)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f (f b) -&gt; NEMap Natural (f (f b))
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span class="hs-comment">-- | Appends the items back-to-back, shifting all of the items in the</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- second map.  Matches the behavior as the fixed-point of 'These1'.</span><span>
</span><span id="line-252"></span><span id="local-6989586621679615619"><span id="local-6989586621679615620"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615614"><span id="local-6989586621679615616"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615620"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615619"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-253"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615612"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679615612"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679615611"><span class="annot"><span class="annottext">&lt;&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615610"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679615610"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-254"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679615609"><span class="annot"><span class="annottext">k :: Natural
</span><a href="#local-6989586621679615609"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; (Natural, f a)
forall k a. NEMap k a -&gt; (k, a)
</span><span class="hs-identifier hs-var">NEM.findMax</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615612"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-255"></span><span>      </span><span class="hs-keyword">in</span><span>  </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615612"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615609"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615610"><span class="hs-identifier hs-var">ys</span></a></span></span></span><span>
</span><span id="line-256"></span><span>
</span><span id="line-257"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-258"></span><span id="local-6989586621679615606"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615603"><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="annot"><a href="#local-6989586621679615606"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615606"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-259"></span><span>    </span><span id="local-6989586621679615602"><span class="annot"><span class="annottext">contramap :: (a -&gt; b) -&gt; Steps f b -&gt; Steps f a
</span><a href="#local-6989586621679615602"><span class="hs-identifier hs-var hs-var hs-var hs-var">contramap</span></a></span></span><span> </span><span id="local-6989586621679615601"><span class="annot"><span class="annottext">f :: a -&gt; b
</span><a href="#local-6989586621679615601"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615600"><span class="annot"><span class="annottext">xs :: NEMap Natural (f b)
</span><a href="#local-6989586621679615600"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f b -&gt; f a) -&gt; NEMap Natural (f b) -&gt; NEMap Natural (f a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">((f b -&gt; f a) -&gt; NEMap Natural (f b) -&gt; NEMap Natural (f a))
-&gt; ((a -&gt; b) -&gt; f b -&gt; f a)
-&gt; (a -&gt; b)
-&gt; NEMap Natural (f b)
-&gt; NEMap Natural (f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; f b -&gt; f a
forall (f :: * -&gt; *) a b. Contravariant f =&gt; (a -&gt; b) -&gt; f b -&gt; f a
</span><span class="hs-identifier hs-var">contramap</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679615601"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b)
</span><a href="#local-6989586621679615600"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">-- TODO: consider what Divisible/Decidable should be.  Maybe no need to</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- rush into this.</span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-265"></span><span id="local-6989586621679615599"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="annot"><a href="#local-6989586621679615599"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615599"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-266"></span><span>    </span><span id="local-6989586621679615597"><span class="annot"><span class="annottext">invmap :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; Steps f a -&gt; Steps f b
</span><a href="#local-6989586621679615597"><span class="hs-identifier hs-var hs-var hs-var hs-var">invmap</span></a></span></span><span> </span><span id="local-6989586621679615596"><span class="annot"><span class="annottext">f :: a -&gt; b
</span><a href="#local-6989586621679615596"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679615595"><span class="annot"><span class="annottext">g :: b -&gt; a
</span><a href="#local-6989586621679615595"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615594"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679615594"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; f b) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; (b -&gt; a) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b.
Invariant f =&gt;
(a -&gt; b) -&gt; (b -&gt; a) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">invmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679615596"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; a
</span><a href="#local-6989586621679615595"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615594"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="hs-comment">-- | Left-biased untion</span><span>
</span><span id="line-270"></span><span id="local-6989586621679615593"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615587"><span id="local-6989586621679615589"><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679615593"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615593"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-271"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615585"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679615585"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679615584"><span class="annot"><span class="annottext">&lt;!&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679615582"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679615582"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k a. Ord k =&gt; NEMap k a -&gt; NEMap k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.union</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615585"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679615582"><span class="hs-identifier hs-var">ys</span></a></span></span><span>
</span><span id="line-272"></span><span>
</span><span id="line-273"></span><span id="local-6989586621679615580"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679615580"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615580"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-274"></span><span>    </span><span id="local-6989586621679615578"><span class="annot"><span class="annottext">point :: a -&gt; Steps f a
</span><a href="#local-6989586621679615578"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; (a -&gt; NEMap Natural (f a)) -&gt; a -&gt; Steps f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NEMap Natural (f a))
-&gt; (a -&gt; f a) -&gt; a -&gt; NEMap Natural (f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-275"></span><span>
</span><span id="line-276"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Steps'.  This is basically</span><span>
</span><span id="line-277"></span><span class="hs-comment">-- a witness that 'stepsDown' and 'stepsUp' form an isomorphism.</span><span>
</span><span id="line-278"></span><span id="local-6989586621679615576"><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-type">steppings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615576"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615576"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615576"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-279"></span><span id="steppings"><span class="annot"><span class="annottext">steppings :: p (These1 f (Steps f) a) (These1 f (Steps f) a)
-&gt; p (Steps f a) (Steps f a)
</span><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-var hs-var">steppings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Steps f ~&gt; These1 f (Steps f))
-&gt; (These1 f (Steps f) ~&gt; Steps f)
-&gt; Steps f &lt;~&gt; These1 f (Steps f)
forall k (f :: k -&gt; *) (g :: k -&gt; *).
(f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Steps f ~&gt; These1 f (Steps f)
forall (f :: * -&gt; *). Steps f ~&gt; These1 f (Steps f)
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var">stepsDown</span></a></span><span> </span><span class="annot"><span class="annottext">These1 f (Steps f) ~&gt; Steps f
forall (f :: * -&gt; *). These1 f (Steps f) ~&gt; Steps f
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var">stepsUp</span></a></span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">-- | Pop off the first item in a 'Steps'.  Because a @'Steps' f@ is @f</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- `These1` f `These1` f `These1` ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-283"></span><span class="hs-comment">--</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-285"></span><span class="hs-comment">--</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-288"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-289"></span><span class="hs-comment">--</span><span>
</span><span id="line-290"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-291"></span><span class="hs-comment">--</span><span>
</span><span id="line-292"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-293"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-294"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-295"></span><span class="hs-comment">--</span><span>
</span><span id="line-296"></span><span class="hs-comment">-- It returns:</span><span>
</span><span id="line-297"></span><span class="hs-comment">--</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- *  'This1' if the first item is the /only/ item in the 'Steps'</span><span>
</span><span id="line-299"></span><span class="hs-comment">-- *  'That1' if the first item in the 'Steps' is empty, but there are more</span><span>
</span><span id="line-300"></span><span class="hs-comment">--    items left.  The extra items are all shfited down.</span><span>
</span><span id="line-301"></span><span class="hs-comment">-- *  'These1' if the first item in the 'Steps' exists, and there are also</span><span>
</span><span id="line-302"></span><span class="hs-comment">--    more items left.  The extra items are all shifted down.</span><span>
</span><span id="line-303"></span><span class="hs-comment">--</span><span>
</span><span id="line-304"></span><span class="hs-comment">-- Forms an isomorphism with 'stepsUp' (see 'steppings').</span><span>
</span><span id="line-305"></span><span id="local-6989586621679616597"><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-type">stepsDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616597"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679616597"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616597"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-306"></span><span id="stepsDown"><span class="annot"><span class="annottext">stepsDown :: Steps f x -&gt; These1 f (Steps f) x
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var hs-var">stepsDown</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f x -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These1 f (Steps f) x)
-&gt; (f x -&gt; Steps f x -&gt; These1 f (Steps f) x)
-&gt; These (f x) (Steps f x)
-&gt; These1 f (Steps f) x
forall a c b.
(a -&gt; c) -&gt; (b -&gt; c) -&gt; (a -&gt; b -&gt; c) -&gt; These a b -&gt; c
</span><span class="hs-identifier hs-var">these</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">This1</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">That1</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">These1</span></span><span>
</span><span id="line-307"></span><span>          </span><span class="annot"><span class="annottext">(These (f x) (Steps f x) -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These (f x) (Steps f x))
-&gt; Steps f x
-&gt; These1 f (Steps f) x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(First (f x) -&gt; f x)
-&gt; (NEMap Natural (f x) -&gt; Steps f x)
-&gt; These (First (f x)) (NEMap Natural (f x))
-&gt; These (f x) (Steps f x)
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">First (f x) -&gt; f x
forall a. First a -&gt; a
</span><span class="hs-identifier hs-var hs-var">getFirst</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span>
</span><span id="line-308"></span><span>          </span><span class="annot"><span class="annottext">(These (First (f x)) (NEMap Natural (f x))
 -&gt; These (f x) (Steps f x))
-&gt; (Steps f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; Steps f x
-&gt; These (f x) (Steps f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x))
forall m k a. Semigroup m =&gt; (k -&gt; a -&gt; m) -&gt; NEMap k a -&gt; m
</span><span class="hs-identifier hs-var">NEM.foldMapWithKey</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x))
forall k (f :: k -&gt; *) (a :: k).
Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var">decr</span></a></span><span>
</span><span id="line-309"></span><span>          </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; These (First (f x)) (NEMap Natural (f x))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span id="local-6989586621679616573"><span id="local-6989586621679616574"><span class="annot"><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-type">decr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679616574"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616573"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">First</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679616574"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616573"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679616574"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616573"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-312"></span><span id="decr"><span class="annot"><span class="annottext">decr :: Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var hs-var">decr</span></a></span></span><span> </span><span id="local-6989586621679615567"><span class="annot"><span class="annottext">i :: Natural
</span><a href="#local-6989586621679615567"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679615566"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615566"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615567"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-313"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. a -&gt; These a b
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">(First (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; First (f a)
forall a. a -&gt; First a
</span><span class="hs-identifier hs-var">First</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615566"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-314"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679615563"><span class="annot"><span class="annottext">i' :: Natural
</span><a href="#local-6989586621679615563"><span class="hs-identifier hs-var">i'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. b -&gt; These a b
</span><span class="hs-identifier hs-var">That</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679615563"><span class="hs-identifier hs-var">i'</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615566"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span class="hs-comment">-- | Unshift an item into a 'Steps'.  Because a @'Steps' f@ is @f `These1`</span><span>
</span><span id="line-317"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` ...@ forever, this basically conses an</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- additional possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-319"></span><span class="hs-comment">--</span><span>
</span><span id="line-320"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-321"></span><span class="hs-comment">--</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-327"></span><span class="hs-comment">--</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-331"></span><span class="hs-comment">--</span><span>
</span><span id="line-332"></span><span class="hs-comment">-- If you give:</span><span>
</span><span id="line-333"></span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- *  'This1', then it returns a singleton 'Steps' with one item at</span><span>
</span><span id="line-335"></span><span class="hs-comment">--    index 0</span><span>
</span><span id="line-336"></span><span class="hs-comment">-- *  'That1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-337"></span><span class="hs-comment">--    index.</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- *  'These1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-339"></span><span class="hs-comment">--    index, and adds the given item (the @f@) at index zero.</span><span>
</span><span id="line-340"></span><span class="hs-comment">--</span><span>
</span><span id="line-341"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-342"></span><span id="local-6989586621679616596"><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-type">stepsUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679616596"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616596"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616596"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-343"></span><span id="stepsUp"><span class="annot"><span class="annottext">stepsUp :: These1 f (Steps f) x -&gt; Steps f x
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var hs-var">stepsUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-344"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">This1</span></span><span>  </span><span id="local-6989586621679615561"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679615561"><span class="hs-identifier hs-var">x</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; NEMap Natural (f x) -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615561"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-345"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">That1</span></span><span>    </span><span id="local-6989586621679615560"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679615560"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-346"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-347"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679615560"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-348"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span id="local-6989586621679615559"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679615559"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615558"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679615558"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Map Natural (f x) -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; Map k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.insertMapMin</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679615559"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-349"></span><span>                         </span><span class="annot"><span class="annottext">(Map Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; Map Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Map Natural (f x)
forall k a. NEMap k a -&gt; Map k a
</span><span class="hs-identifier hs-var">NEM.toMap</span></span><span>
</span><span id="line-350"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Map Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; Map Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-351"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-352"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679615558"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-353"></span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span class="hs-comment">-- | An @f a@, along with a 'Bool' flag</span><span>
</span><span id="line-356"></span><span class="hs-comment">--</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-358"></span><span class="hs-comment">-- 'Flagged' f a ~ ('Bool', f a)</span><span>
</span><span id="line-359"></span><span class="hs-comment">-- Flagged f   ~ ((,) Bool) ':.:' f       -- functor composition</span><span>
</span><span id="line-360"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-361"></span><span class="hs-comment">--</span><span>
</span><span id="line-362"></span><span class="hs-comment">-- Creation with 'Data.HFunctor.inject' or 'pure' uses 'False' as the</span><span>
</span><span id="line-363"></span><span class="hs-comment">-- boolean.</span><span>
</span><span id="line-364"></span><span class="hs-comment">--</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- You can think of it as an @f a@ that is &quot;flagged&quot; with a boolean value,</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- and that value can indicuate whether or not it is &quot;pure&quot; (made with</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- 'Data.HFunctor.inject' or 'pure') as 'False', or &quot;impure&quot;</span><span>
</span><span id="line-368"></span><span class="hs-comment">-- (made from some other source) as 'True'.  However, 'False' may be always</span><span>
</span><span id="line-369"></span><span class="hs-comment">-- created directly, of course, using the constructor.</span><span>
</span><span id="line-370"></span><span class="hs-comment">--</span><span>
</span><span id="line-371"></span><span class="hs-comment">-- You can think of it like a 'Step' that is either 0 or 1, as well.</span><span>
</span><span id="line-372"></span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-374"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-375"></span><span class="hs-comment">--</span><span>
</span><span id="line-376"></span><span class="hs-comment">-- This type is equivalent (along with its instances) to:</span><span>
</span><span id="line-377"></span><span class="hs-comment">--</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- *   @'Data.HFunctor.HLift' 'Control.Monad.Trans.Identity.IdentityT'@</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- *   @'Control.COmonad.Trans.Env.EnvT' 'Data.Semigroup.Any'@</span><span>
</span><span id="line-380"></span><span id="local-6989586621679615554"><span id="local-6989586621679615555"></span></span><span class="hs-keyword">data</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span id="local-6989586621679616454"><span class="annot"><a href="#local-6989586621679616454"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679616453"><span class="annot"><a href="#local-6989586621679616453"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="flaggedFlag"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
</span><a href="Control.Applicative.Step.html#flaggedFlag"><span class="hs-identifier hs-var hs-var">flaggedFlag</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">,</span><span> </span><span id="flaggedVal"><span class="annot"><span class="annottext">Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679616454"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616453"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679615545"><span id="local-6989586621679615547"><span id="local-6989586621679615549"><span class="annot"><span class="annottext">Int -&gt; Flagged f a -&gt; ShowS
[Flagged f a] -&gt; ShowS
Flagged f a -&gt; String
(Int -&gt; Flagged f a -&gt; ShowS)
-&gt; (Flagged f a -&gt; String)
-&gt; ([Flagged f a] -&gt; ShowS)
-&gt; Show (Flagged f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showList :: [Flagged f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
show :: Flagged f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showsPrec :: Int -&gt; Flagged f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615537"><span id="local-6989586621679615539"><span id="local-6989586621679615541"><span id="local-6989586621679615543"><span class="annot"><span class="annottext">ReadPrec [Flagged f a]
ReadPrec (Flagged f a)
Int -&gt; ReadS (Flagged f a)
ReadS [Flagged f a]
(Int -&gt; ReadS (Flagged f a))
-&gt; ReadS [Flagged f a]
-&gt; ReadPrec (Flagged f a)
-&gt; ReadPrec [Flagged f a]
-&gt; Read (Flagged f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readListPrec :: ReadPrec [Flagged f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
readPrec :: ReadPrec (Flagged f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
readList :: ReadS [Flagged f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readsPrec :: Int -&gt; ReadS (Flagged f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615533"><span id="local-6989586621679615535"><span class="annot"><span class="annottext">Flagged f a -&gt; Flagged f a -&gt; Bool
(Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool) -&gt; Eq (Flagged f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
/= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
== :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615518"><span id="local-6989586621679615520"><span id="local-6989586621679615522"><span id="local-6989586621679615524"><span id="local-6989586621679615526"><span id="local-6989586621679615528"><span id="local-6989586621679615530"><span class="annot"><span class="annottext">Eq (Flagged f a)
Eq (Flagged f a) =&gt;
(Flagged f a -&gt; Flagged f a -&gt; Ordering)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; Ord (Flagged f a)
Flagged f a -&gt; Flagged f a -&gt; Bool
Flagged f a -&gt; Flagged f a -&gt; Ordering
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
min :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
max :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
&gt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&gt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
compare :: Flagged f a -&gt; Flagged f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615514"><span id="local-6989586621679615516"><span class="annot"><span class="annottext">a -&gt; Flagged f b -&gt; Flagged f a
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
(forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b)
-&gt; (forall a b. a -&gt; Flagged f b -&gt; Flagged f a)
-&gt; Functor (Flagged f)
forall a b. a -&gt; Flagged f b -&gt; Flagged f a
forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Flagged f b -&gt; Flagged f a
$c&lt;$ :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
fmap :: (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615480"><span id="local-6989586621679615482"><span id="local-6989586621679615484"><span id="local-6989586621679615486"><span id="local-6989586621679615488"><span id="local-6989586621679615490"><span id="local-6989586621679615492"><span id="local-6989586621679615494"><span id="local-6989586621679615496"><span id="local-6989586621679615498"><span id="local-6989586621679615500"><span id="local-6989586621679615502"><span id="local-6989586621679615504"><span id="local-6989586621679615506"><span id="local-6989586621679615508"><span id="local-6989586621679615510"><span id="local-6989586621679615512"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
(a -&gt; m) -&gt; Flagged f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
(forall m. Monoid m =&gt; Flagged f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. Flagged f a -&gt; [a])
-&gt; (forall a. Flagged f a -&gt; Bool)
-&gt; (forall a. Flagged f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; Foldable (Flagged f)
forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool
forall a. Num a =&gt; Flagged f a -&gt; a
forall a. Ord a =&gt; Flagged f a -&gt; a
forall m. Monoid m =&gt; Flagged f m -&gt; m
forall a. Flagged f a -&gt; Bool
forall a. Flagged f a -&gt; Int
forall a. Flagged f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Flagged f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
sum :: Flagged f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
minimum :: Flagged f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
maximum :: Flagged f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
elem :: a -&gt; Flagged f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
length :: Flagged f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
null :: Flagged f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
toList :: Flagged f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
fold :: Flagged f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615470"><span id="local-6989586621679615472"><span id="local-6989586621679615474"><span id="local-6989586621679615476"><span class="annot"><span class="annottext">Functor (Flagged f)
Foldable (Flagged f)
(Functor (Flagged f), Foldable (Flagged f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Flagged f (f a) -&gt; f (Flagged f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Flagged f (m a) -&gt; m (Flagged f a))
-&gt; Traversable (Flagged f)
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (m :: * -&gt; *) a.
Monad m =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
sequence :: Flagged f (m a) -&gt; m (Flagged f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
mapM :: (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
sequenceA :: Flagged f (f a) -&gt; f (Flagged f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
traverse :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Flagged f a -&gt; Rep (Flagged f a) x)
-&gt; (forall x. Rep (Flagged f a) x -&gt; Flagged f a)
-&gt; Generic (Flagged f a)
forall x. Rep (Flagged f a) x -&gt; Flagged f a
forall x. Flagged f a -&gt; Rep (Flagged f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cFlagged"><span id="%24tFlagged"><span id="local-6989586621679615439"><span id="local-6989586621679615441"><span id="local-6989586621679615443"><span id="local-6989586621679615445"><span id="local-6989586621679615447"><span id="local-6989586621679615449"><span id="local-6989586621679615451"><span id="local-6989586621679615453"><span id="local-6989586621679615455"><span id="local-6989586621679615457"><span id="local-6989586621679615459"><span id="local-6989586621679615461"><span id="local-6989586621679615463"><span id="local-6989586621679615465"><span class="annot"><span class="annottext">Typeable (Flagged f a)
DataType
Constr
Typeable (Flagged f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a))
-&gt; (Flagged f a -&gt; Constr)
-&gt; (Flagged f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Flagged f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; Data (Flagged f a)
Flagged f a -&gt; DataType
Flagged f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cFlagged :: Constr
$tFlagged :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
dataTypeOf :: Flagged f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
toConstr :: Flagged f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span id="local-6989586621679615433"><span id="local-6989586621679615435"><span id="local-6989586621679616454"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span><span>
</span><span id="line-384"></span><span id="local-6989586621679615425"><span id="local-6989586621679615427"><span id="local-6989586621679615429"><span id="local-6989586621679615431"><span id="local-6989586621679616454"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span></span></span><span>
</span><span id="line-385"></span><span id="local-6989586621679615423"><span id="local-6989586621679616454"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-386"></span><span id="local-6989586621679615420"><span id="local-6989586621679616454"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span class="hs-comment">-- | Uses 'False' for 'pure', and '||' for '&lt;*&gt;'.</span><span>
</span><span id="line-389"></span><span id="local-6989586621679615419"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615410"><span id="local-6989586621679615412"><span id="local-6989586621679615414"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679615419"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615419"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-390"></span><span>    </span><span id="local-6989586621679615409"><span class="annot"><span class="annottext">pure :: a -&gt; Flagged f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-391"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679615408"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679615408"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615407"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679615407"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679615406"><span class="annot"><span class="annottext">&lt;*&gt; :: Flagged f (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679615405"><span class="annot"><span class="annottext">m :: Bool
</span><a href="#local-6989586621679615405"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679615404"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615404"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679615408"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679615405"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679615407"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615404"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-392"></span><span>
</span><span id="line-393"></span><span class="hs-comment">-- | Uses 'False' for 'point'.</span><span>
</span><span id="line-394"></span><span id="local-6989586621679615402"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679615402"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615402"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-395"></span><span>    </span><span id="local-6989586621679615400"><span class="annot"><span class="annottext">point :: a -&gt; Flagged f a
</span><a href="#local-6989586621679615400"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-396"></span><span>
</span><span id="line-397"></span><span id="local-6989586621679615399"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615399"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615399"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-398"></span><span>    </span><span id="local-6989586621679615394"><span class="annot"><span class="annottext">fold1 :: Flagged f m -&gt; m
</span><a href="#local-6989586621679615394"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Flagged f m -&gt; f m) -&gt; Flagged f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-399"></span><span>    </span><span id="local-6989586621679615393"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Flagged f a -&gt; m
</span><a href="#local-6989586621679615393"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679615392"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679615392"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679615392"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-400"></span><span>    </span><span id="local-6989586621679615391"><span class="annot"><span class="annottext">toNonEmpty :: Flagged f a -&gt; NonEmpty a
</span><a href="#local-6989586621679615391"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a)
-&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span>
</span><span id="line-401"></span><span>
</span><span id="line-402"></span><span id="local-6989586621679615390"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679615390"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615390"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-403"></span><span>    </span><span id="local-6989586621679615385"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
</span><a href="#local-6989586621679615385"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679615384"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679615384"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679615383"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679615383"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615382"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679615382"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679615383"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679615384"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679615382"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-404"></span><span>    </span><span id="local-6989586621679615381"><span class="annot"><span class="annottext">sequence1 :: Flagged f (f b) -&gt; f (Flagged f b)
</span><a href="#local-6989586621679615381"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679615380"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679615380"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679615379"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679615379"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679615380"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679615379"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-405"></span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span class="hs-comment">-- | @'Void2' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-411"></span><span id="local-6989586621679615377"><span id="local-6989586621679615378"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void2"><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-var">Void2</span></a></span></span><span> </span><span id="local-6989586621679615376"><span class="annot"><a href="#local-6989586621679615376"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679615375"><span class="annot"><a href="#local-6989586621679615375"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-412"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679615369"><span id="local-6989586621679615371"><span id="local-6989586621679615373"><span class="annot"><span class="annottext">Int -&gt; Void2 a b -&gt; ShowS
[Void2 a b] -&gt; ShowS
Void2 a b -&gt; String
(Int -&gt; Void2 a b -&gt; ShowS)
-&gt; (Void2 a b -&gt; String)
-&gt; ([Void2 a b] -&gt; ShowS)
-&gt; Show (Void2 a b)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showList :: [Void2 a b] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
show :: Void2 a b -&gt; String
$cshow :: forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showsPrec :: Int -&gt; Void2 a b -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615361"><span id="local-6989586621679615363"><span id="local-6989586621679615365"><span id="local-6989586621679615367"><span class="annot"><span class="annottext">ReadPrec [Void2 a b]
ReadPrec (Void2 a b)
Int -&gt; ReadS (Void2 a b)
ReadS [Void2 a b]
(Int -&gt; ReadS (Void2 a b))
-&gt; ReadS [Void2 a b]
-&gt; ReadPrec (Void2 a b)
-&gt; ReadPrec [Void2 a b]
-&gt; Read (Void2 a b)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readListPrec :: ReadPrec [Void2 a b]
$creadListPrec :: forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
readPrec :: ReadPrec (Void2 a b)
$creadPrec :: forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
readList :: ReadS [Void2 a b]
$creadList :: forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readsPrec :: Int -&gt; ReadS (Void2 a b)
$creadsPrec :: forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615357"><span id="local-6989586621679615359"><span class="annot"><span class="annottext">Void2 a b -&gt; Void2 a b -&gt; Bool
(Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool) -&gt; Eq (Void2 a b)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
/= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
== :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c== :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615342"><span id="local-6989586621679615344"><span id="local-6989586621679615346"><span id="local-6989586621679615348"><span id="local-6989586621679615350"><span id="local-6989586621679615352"><span id="local-6989586621679615354"><span class="annot"><span class="annottext">Eq (Void2 a b)
Eq (Void2 a b) =&gt;
(Void2 a b -&gt; Void2 a b -&gt; Ordering)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; Ord (Void2 a b)
Void2 a b -&gt; Void2 a b -&gt; Bool
Void2 a b -&gt; Void2 a b -&gt; Ordering
Void2 a b -&gt; Void2 a b -&gt; Void2 a b
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k). Eq (Void2 a b)
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
min :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmin :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
max :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmax :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
&gt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&gt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
compare :: Void2 a b -&gt; Void2 a b -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k). Eq (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615338"><span id="local-6989586621679615340"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
(forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b)
-&gt; (forall a b. a -&gt; Void2 a b -&gt; Void2 a a) -&gt; Functor (Void2 a)
forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall a b. a -&gt; Void2 a b -&gt; Void2 a a
forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void2 a b -&gt; Void2 a a
$c&lt;$ :: forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
fmap :: (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
$cfmap :: forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615304"><span id="local-6989586621679615306"><span id="local-6989586621679615308"><span id="local-6989586621679615310"><span id="local-6989586621679615312"><span id="local-6989586621679615314"><span id="local-6989586621679615316"><span id="local-6989586621679615318"><span id="local-6989586621679615320"><span id="local-6989586621679615322"><span id="local-6989586621679615324"><span id="local-6989586621679615326"><span id="local-6989586621679615328"><span id="local-6989586621679615330"><span id="local-6989586621679615332"><span id="local-6989586621679615334"><span id="local-6989586621679615336"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void2 a a -&gt; m
(forall m. Monoid m =&gt; Void2 a m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. Void2 a a -&gt; [a])
-&gt; (forall a. Void2 a a -&gt; Bool)
-&gt; (forall a. Void2 a a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; Foldable (Void2 a)
forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall a. Num a =&gt; Void2 a a -&gt; a
forall a. Ord a =&gt; Void2 a a -&gt; a
forall m. Monoid m =&gt; Void2 a m -&gt; m
forall a. Void2 a a -&gt; Bool
forall a. Void2 a a -&gt; Int
forall a. Void2 a a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
forall k (a :: k) a. Void2 a a -&gt; Bool
forall k (a :: k) a. Void2 a a -&gt; Int
forall k (a :: k) a. Void2 a a -&gt; [a]
forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void2 a a -&gt; a
$cproduct :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
sum :: Void2 a a -&gt; a
$csum :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
minimum :: Void2 a a -&gt; a
$cminimum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
maximum :: Void2 a a -&gt; a
$cmaximum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
elem :: a -&gt; Void2 a a -&gt; Bool
$celem :: forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
length :: Void2 a a -&gt; Int
$clength :: forall k (a :: k) a. Void2 a a -&gt; Int
null :: Void2 a a -&gt; Bool
$cnull :: forall k (a :: k) a. Void2 a a -&gt; Bool
toList :: Void2 a a -&gt; [a]
$ctoList :: forall k (a :: k) a. Void2 a a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldl1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldr1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl' :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr' :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap' :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
fold :: Void2 a m -&gt; m
$cfold :: forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615294"><span id="local-6989586621679615296"><span id="local-6989586621679615298"><span id="local-6989586621679615300"><span class="annot"><span class="annottext">Functor (Void2 a)
Foldable (Void2 a)
(Functor (Void2 a), Foldable (Void2 a)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void2 a (f a) -&gt; f (Void2 a a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void2 a (m a) -&gt; m (Void2 a a))
-&gt; Traversable (Void2 a)
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall k (a :: k). Functor (Void2 a)
forall k (a :: k). Foldable (Void2 a)
forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Void2 a (m a) -&gt; m (Void2 a a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
sequence :: Void2 a (m a) -&gt; m (Void2 a a)
$csequence :: forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
mapM :: (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
$cmapM :: forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
sequenceA :: Void2 a (f a) -&gt; f (Void2 a a)
$csequenceA :: forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
traverse :: (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$ctraverse :: forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$cp2Traversable :: forall k (a :: k). Foldable (Void2 a)
$cp1Traversable :: forall k (a :: k). Functor (Void2 a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void2 a b -&gt; Rep (Void2 a b) x)
-&gt; (forall x. Rep (Void2 a b) x -&gt; Void2 a b)
-&gt; Generic (Void2 a b)
forall x. Rep (Void2 a b) x -&gt; Void2 a b
forall x. Void2 a b -&gt; Rep (Void2 a b) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
$cto :: forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
$cfrom :: forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid2"><span id="local-6989586621679615263"><span id="local-6989586621679615265"><span id="local-6989586621679615267"><span id="local-6989586621679615269"><span id="local-6989586621679615271"><span id="local-6989586621679615273"><span id="local-6989586621679615275"><span id="local-6989586621679615277"><span id="local-6989586621679615279"><span id="local-6989586621679615281"><span id="local-6989586621679615283"><span id="local-6989586621679615285"><span id="local-6989586621679615287"><span id="local-6989586621679615289"><span class="annot"><span class="annottext">Typeable (Void2 a b)
DataType
Typeable (Void2 a b) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b))
-&gt; (Void2 a b -&gt; Constr)
-&gt; (Void2 a b -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void2 a b)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; Data (Void2 a b)
Void2 a b -&gt; DataType
Void2 a b -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$tVoid2 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMo :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMp :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
$cgmapT :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$cdataCast2 :: forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
$cdataCast1 :: forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
dataTypeOf :: Void2 a b -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
toConstr :: Void2 a b -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
$cgunfold :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cgfoldl :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cp1Data :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-413"></span><span>
</span><span id="line-414"></span><span id="local-6989586621679615258"><span id="local-6989586621679615260"><span id="local-6989586621679615376"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span><span>
</span><span id="line-415"></span><span id="local-6989586621679615250"><span id="local-6989586621679615252"><span id="local-6989586621679615254"><span id="local-6989586621679615256"><span id="local-6989586621679615376"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span></span></span><span>
</span><span id="line-416"></span><span id="local-6989586621679615248"><span id="local-6989586621679615376"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-417"></span><span id="local-6989586621679615245"><span id="local-6989586621679615376"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-418"></span><span>
</span><span id="line-419"></span><span id="local-6989586621679615243"><span id="local-6989586621679615244"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615238"><span id="local-6989586621679615240"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615244"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615243"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-420"></span><span>    </span><span id="local-6989586621679615237"><span class="annot"><span class="annottext">x :: Void2 a b
</span><a href="#local-6989586621679615237"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615236"><span class="annot"><span class="annottext">&lt;&gt; :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a b
</span><a href="#local-6989586621679615237"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span id="local-6989586621679615235"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615229"><span id="local-6989586621679615231"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615235"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-423"></span><span>    </span><span id="local-6989586621679615228"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679615228"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615227"><span class="annot"><span class="annottext">&lt;!&gt; :: Void2 a a -&gt; Void2 a a -&gt; Void2 a a
</span><a href="#local-6989586621679615227"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void2 a a -&gt; Void2 a a
forall k k (f :: k) (a :: k) (t :: k -&gt; k -&gt; *). Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var">absurd2</span></a></span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679615228"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-424"></span><span>
</span><span id="line-425"></span><span id="local-6989586621679615226"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615222"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615226"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-426"></span><span>    </span><span id="local-6989586621679615220"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679615220"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615219"><span class="annot"><span class="annottext">&gt;&gt;- :: Void2 a a -&gt; (a -&gt; Void2 a b) -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679615220"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span id="local-6989586621679615217"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615209"><span id="local-6989586621679615211"><span id="local-6989586621679615213"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615217"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-429"></span><span>    </span><span id="local-6989586621679615208"><span class="annot"><span class="annottext">x :: Void2 a (a -&gt; b)
</span><a href="#local-6989586621679615208"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615207"><span class="annot"><span class="annottext">&lt;.&gt; :: Void2 a (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><a href="#local-6989586621679615207"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a (a -&gt; b)
</span><a href="#local-6989586621679615208"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-430"></span><span>
</span><span id="line-431"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-432"></span><span id="local-6989586621679615206"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615203"><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615206"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-433"></span><span>    </span><span id="local-6989586621679615202"><span class="annot"><span class="annottext">contramap :: (a -&gt; b) -&gt; Void2 a b -&gt; Void2 a a
</span><a href="#local-6989586621679615202"><span class="hs-identifier hs-var hs-var hs-var hs-var">contramap</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-434"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-435"></span><span id="local-6989586621679615201"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615201"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-436"></span><span>    </span><span id="local-6989586621679615199"><span class="annot"><span class="annottext">invmap :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; Void2 a a -&gt; Void2 a b
</span><a href="#local-6989586621679615199"><span class="hs-identifier hs-var hs-var hs-var hs-var">invmap</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-437"></span><span>
</span><span id="line-438"></span><span class="hs-comment">-- | If you treat a @'Void2' f a@ as a functor combinator, then 'absurd2'</span><span>
</span><span id="line-439"></span><span class="hs-comment">-- lets you convert from a @'Void2' f a@ into a @t f a@ for any functor</span><span>
</span><span id="line-440"></span><span class="hs-comment">-- combinator @t@.</span><span>
</span><span id="line-441"></span><span id="local-6989586621679616320"><span id="local-6989586621679616321"><span id="local-6989586621679616322"><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-type">absurd2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616322"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616321"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679616320"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616322"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616321"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-442"></span><span id="absurd2"><span class="annot"><span class="annottext">absurd2 :: Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var hs-var">absurd2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span class="hs-comment">-- | @'Void3' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-445"></span><span id="local-6989586621679615197"><span id="local-6989586621679615198"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void3"><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-var">Void3</span></a></span></span><span> </span><span id="local-6989586621679615196"><span class="annot"><a href="#local-6989586621679615196"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679615195"><span class="annot"><a href="#local-6989586621679615195"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679615194"><span class="annot"><a href="#local-6989586621679615194"><span class="hs-identifier hs-type">c</span></a></span></span><span>
</span><span id="line-446"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679615188"><span id="local-6989586621679615190"><span id="local-6989586621679615192"><span class="annot"><span class="annottext">Int -&gt; Void3 a b c -&gt; ShowS
[Void3 a b c] -&gt; ShowS
Void3 a b c -&gt; String
(Int -&gt; Void3 a b c -&gt; ShowS)
-&gt; (Void3 a b c -&gt; String)
-&gt; ([Void3 a b c] -&gt; ShowS)
-&gt; Show (Void3 a b c)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showList :: [Void3 a b c] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
show :: Void3 a b c -&gt; String
$cshow :: forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showsPrec :: Int -&gt; Void3 a b c -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615180"><span id="local-6989586621679615182"><span id="local-6989586621679615184"><span id="local-6989586621679615186"><span class="annot"><span class="annottext">ReadPrec [Void3 a b c]
ReadPrec (Void3 a b c)
Int -&gt; ReadS (Void3 a b c)
ReadS [Void3 a b c]
(Int -&gt; ReadS (Void3 a b c))
-&gt; ReadS [Void3 a b c]
-&gt; ReadPrec (Void3 a b c)
-&gt; ReadPrec [Void3 a b c]
-&gt; Read (Void3 a b c)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readListPrec :: ReadPrec [Void3 a b c]
$creadListPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
readPrec :: ReadPrec (Void3 a b c)
$creadPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
readList :: ReadS [Void3 a b c]
$creadList :: forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readsPrec :: Int -&gt; ReadS (Void3 a b c)
$creadsPrec :: forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615176"><span id="local-6989586621679615178"><span class="annot"><span class="annottext">Void3 a b c -&gt; Void3 a b c -&gt; Bool
(Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool) -&gt; Eq (Void3 a b c)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
/= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
== :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c== :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615161"><span id="local-6989586621679615163"><span id="local-6989586621679615165"><span id="local-6989586621679615167"><span id="local-6989586621679615169"><span id="local-6989586621679615171"><span id="local-6989586621679615173"><span class="annot"><span class="annottext">Eq (Void3 a b c)
Eq (Void3 a b c) =&gt;
(Void3 a b c -&gt; Void3 a b c -&gt; Ordering)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; Ord (Void3 a b c)
Void3 a b c -&gt; Void3 a b c -&gt; Bool
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
min :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmin :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
max :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmax :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
&gt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
compare :: Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615157"><span id="local-6989586621679615159"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
(forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b)
-&gt; (forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a)
-&gt; Functor (Void3 a b)
forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void3 a b b -&gt; Void3 a b a
$c&lt;$ :: forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
fmap :: (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
$cfmap :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615123"><span id="local-6989586621679615125"><span id="local-6989586621679615127"><span id="local-6989586621679615129"><span id="local-6989586621679615131"><span id="local-6989586621679615133"><span id="local-6989586621679615135"><span id="local-6989586621679615137"><span id="local-6989586621679615139"><span id="local-6989586621679615141"><span id="local-6989586621679615143"><span id="local-6989586621679615145"><span id="local-6989586621679615147"><span id="local-6989586621679615149"><span id="local-6989586621679615151"><span id="local-6989586621679615153"><span id="local-6989586621679615155"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void3 a b a -&gt; m
(forall m. Monoid m =&gt; Void3 a b m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Void3 a b a -&gt; [a])
-&gt; (forall a. Void3 a b a -&gt; Bool)
-&gt; (forall a. Void3 a b a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; Foldable (Void3 a b)
forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall a. Num a =&gt; Void3 a b a -&gt; a
forall a. Ord a =&gt; Void3 a b a -&gt; a
forall m. Monoid m =&gt; Void3 a b m -&gt; m
forall a. Void3 a b a -&gt; Bool
forall a. Void3 a b a -&gt; Int
forall a. Void3 a b a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void3 a b a -&gt; a
$cproduct :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
sum :: Void3 a b a -&gt; a
$csum :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
minimum :: Void3 a b a -&gt; a
$cminimum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
maximum :: Void3 a b a -&gt; a
$cmaximum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
elem :: a -&gt; Void3 a b a -&gt; Bool
$celem :: forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
length :: Void3 a b a -&gt; Int
$clength :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
null :: Void3 a b a -&gt; Bool
$cnull :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
toList :: Void3 a b a -&gt; [a]
$ctoList :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldl1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldr1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl' :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr' :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap' :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
fold :: Void3 a b m -&gt; m
$cfold :: forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679615113"><span id="local-6989586621679615115"><span id="local-6989586621679615117"><span id="local-6989586621679615119"><span class="annot"><span class="annottext">Functor (Void3 a b)
Foldable (Void3 a b)
(Functor (Void3 a b), Foldable (Void3 a b)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void3 a b (f a) -&gt; f (Void3 a b a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void3 a b (m a) -&gt; m (Void3 a b a))
-&gt; Traversable (Void3 a b)
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall k (a :: k) k (b :: k). Functor (Void3 a b)
forall k (a :: k) k (b :: k). Foldable (Void3 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
sequence :: Void3 a b (m a) -&gt; m (Void3 a b a)
$csequence :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
mapM :: (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
$cmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
sequenceA :: Void3 a b (f a) -&gt; f (Void3 a b a)
$csequenceA :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
traverse :: (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$ctraverse :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$cp2Traversable :: forall k (a :: k) k (b :: k). Foldable (Void3 a b)
$cp1Traversable :: forall k (a :: k) k (b :: k). Functor (Void3 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void3 a b c -&gt; Rep (Void3 a b c) x)
-&gt; (forall x. Rep (Void3 a b c) x -&gt; Void3 a b c)
-&gt; Generic (Void3 a b c)
forall x. Rep (Void3 a b c) x -&gt; Void3 a b c
forall x. Void3 a b c -&gt; Rep (Void3 a b c) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
$cto :: forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
$cfrom :: forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid3"><span id="local-6989586621679615082"><span id="local-6989586621679615084"><span id="local-6989586621679615086"><span id="local-6989586621679615088"><span id="local-6989586621679615090"><span id="local-6989586621679615092"><span id="local-6989586621679615094"><span id="local-6989586621679615096"><span id="local-6989586621679615098"><span id="local-6989586621679615100"><span id="local-6989586621679615102"><span id="local-6989586621679615104"><span id="local-6989586621679615106"><span id="local-6989586621679615108"><span class="annot"><span class="annottext">Typeable (Void3 a b c)
DataType
Typeable (Void3 a b c) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c))
-&gt; (Void3 a b c -&gt; Constr)
-&gt; (Void3 a b c -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void3 a b c)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; Data (Void3 a b c)
Void3 a b c -&gt; DataType
Void3 a b c -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$tVoid3 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMo :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMp :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapM :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
$cgmapT :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$cdataCast2 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
$cdataCast1 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
dataTypeOf :: Void3 a b c -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
toConstr :: Void3 a b c -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
$cgunfold :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cgfoldl :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cp1Data :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span id="local-6989586621679615077"><span id="local-6989586621679615079"><span id="local-6989586621679615195"><span id="local-6989586621679615196"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span><span>
</span><span id="line-449"></span><span id="local-6989586621679615069"><span id="local-6989586621679615071"><span id="local-6989586621679615073"><span id="local-6989586621679615075"><span id="local-6989586621679615195"><span id="local-6989586621679615196"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span></span></span><span>
</span><span id="line-450"></span><span id="local-6989586621679615067"><span id="local-6989586621679615195"><span id="local-6989586621679615196"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-451"></span><span id="local-6989586621679615064"><span id="local-6989586621679615195"><span id="local-6989586621679615196"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-452"></span><span>
</span><span id="line-453"></span><span id="local-6989586621679615061"><span id="local-6989586621679615062"><span id="local-6989586621679615063"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615056"><span id="local-6989586621679615058"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615063"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615062"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615061"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-454"></span><span>    </span><span id="local-6989586621679615055"><span class="annot"><span class="annottext">x :: Void3 a b c
</span><a href="#local-6989586621679615055"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615054"><span class="annot"><span class="annottext">&lt;&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b c
</span><a href="#local-6989586621679615055"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span></span><span>
</span><span id="line-455"></span><span>
</span><span id="line-456"></span><span id="local-6989586621679615052"><span id="local-6989586621679615053"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615046"><span id="local-6989586621679615048"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615053"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615052"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-457"></span><span>    </span><span id="local-6989586621679615045"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679615045"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615044"><span class="annot"><span class="annottext">&lt;!&gt; :: Void3 a b a -&gt; Void3 a b a -&gt; Void3 a b a
</span><a href="#local-6989586621679615044"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void3 a b a -&gt; Void3 a b a
forall k k k (f :: k) (g :: k) (a :: k) (t :: k -&gt; k -&gt; k -&gt; *).
Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var">absurd3</span></a></span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679615045"><span class="hs-identifier hs-var">x</span></a></span></span></span><span>
</span><span id="line-458"></span><span>
</span><span id="line-459"></span><span id="local-6989586621679615042"><span id="local-6989586621679615043"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615038"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615043"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615042"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-460"></span><span>    </span><span id="local-6989586621679615037"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679615037"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615036"><span class="annot"><span class="annottext">&gt;&gt;- :: Void3 a b a -&gt; (a -&gt; Void3 a b b) -&gt; Void3 a b b
</span><a href="#local-6989586621679615036"><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679615037"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span id="local-6989586621679615034"><span id="local-6989586621679615035"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615026"><span id="local-6989586621679615028"><span id="local-6989586621679615030"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615035"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615034"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-463"></span><span>    </span><span id="local-6989586621679615025"><span class="annot"><span class="annottext">x :: Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679615025"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679615024"><span class="annot"><span class="annottext">&lt;.&gt; :: Void3 a b (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><a href="#local-6989586621679615024"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679615025"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-464"></span><span>
</span><span id="line-465"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-466"></span><span id="local-6989586621679615022"><span id="local-6989586621679615023"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679615019"><span class="annot"><span class="hs-identifier hs-type">Contravariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615023"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615022"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-467"></span><span>    </span><span id="local-6989586621679615018"><span class="annot"><span class="annottext">contramap :: (a -&gt; b) -&gt; Void3 a b b -&gt; Void3 a b a
</span><a href="#local-6989586621679615018"><span class="hs-identifier hs-var hs-var hs-var hs-var">contramap</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-468"></span><span class="hs-comment">-- | @since 0.3.0.0</span><span>
</span><span id="line-469"></span><span id="local-6989586621679615016"><span id="local-6989586621679615017"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Invariant</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615017"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679615016"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-470"></span><span>    </span><span id="local-6989586621679615014"><span class="annot"><span class="annottext">invmap :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; Void3 a b a -&gt; Void3 a b b
</span><a href="#local-6989586621679615014"><span class="hs-identifier hs-var hs-var hs-var hs-var">invmap</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-471"></span><span>
</span><span id="line-472"></span><span class="hs-comment">-- | If you treat a @'Void3' f a@ as a binary functor combinator, then</span><span>
</span><span id="line-473"></span><span class="hs-comment">-- 'absurd3' lets you convert from a @'Void3' f a@ into a @t f a@ for any</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- functor combinator @t@.</span><span>
</span><span id="line-475"></span><span id="local-6989586621679616134"><span id="local-6989586621679616135"><span id="local-6989586621679616136"><span id="local-6989586621679616137"><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-type">absurd3</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616137"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616136"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616135"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679616134"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616137"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616136"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679616135"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-476"></span><span id="absurd3"><span class="annot"><span class="annottext">absurd3 :: Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var hs-var">absurd3</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-477"></span></pre></body></html>